# 1929 소수 구하기


# 문제 정리 
1. N과 M 사이의 소수를 구한다.

# 문제 풀이
1. 양의 정수 N, M을 BufferdReader를 통하여 입력받는다.
2. 공백을 입력하기 위해서 StringTokenizer를 사용한다.
3. p * q = N 이라고 할 때 p,q 둘중 하나는 반드시 N보다 작다는 것을 이용한 에라토스테네스 체 알고리즘을 이용한다.


```
   for(int i = 2; i < Math.sqrt(prime.length); i++){

            // 중복을 제거한다.
            if (prime[i] == true) continue;;

            // i의 배수를 구한다.
            for(int j = i*i; j < prime.length; j = j+i){
                prime[j] = true;
            }
        }     
```
4. M보다 작은 소수를 구했다면 반복문을 이용하여 prime 배열의 값중 false인 즉 소수를 출력해준다.

# 느낀점
소수를 구하는 3가지 방법을 배웠다. 
첫번째는 n을 2부터 n까지 직접 나누어 구하는 방법
두번째는 n까지가 아닌 제곱근 n까지 나누어 구하는 방법
세번째는 내가 사용한 에라토스테네스 체 알고리즘이다. 
알고리즘을 참고하여 문제를 푸는것은 어렵지 않았지만 반복문의 범위 설정을 잘못하여 문제를 틀렸다.
역시 배열을 사용할때는 크기를 꼼꼼히 생각해서 문제를 풀어야겠다.
또한 함수를 사용하지 않고 main 함수에 모든 로직을 넣었는데 다른 사람들의 코드를 비교하니 메소드를 사용해야겠다는 생각이 들었다.
